# Logging
This project uses a logger in various locations. This is written as a sort of guidebook on best ways to use it.

Using the logger is as simple as writing `log::<method>!(...)` where `<method>` is one of `error`, `warn`, `info`, `debug` or `trace`. `log` is a crate and all the methods are top-level macros. Don't import any macros; explicitly writing `log::<method>` makes it incredibly obvious what you intend to do while importing them loses some of that meaning. The arguments for each macro are the exact same you'd find in `println!`.

When using the logger, try to be mindful of what the output looks like to someone just using the code and not reading it at the same time. If it's quite a verbose statement, or a `Debug` printout (excluding `Option`, as a `None` option gives zero information), then you probably don't need to indicate where it came from, and if it's in the `_cli` file then it's probably immediately obvious. However, a terse statement in a small component will need at least some indication, e.g. "In the battlegrounds section Ms. Sign was skipped over".

## Types
Types of logging and when to use them:

- `trace`: use this to get very detailed information about the inner workings of the code. This isn't yet used anywhere, but I'd imagine the best use is that if you're doing extensive print debugging to fix a certain problem by inspecting the state at multiple points, then once you've finished debugging then convert all of the `println`s to `trace` or `debug`.
- `debug`: use this to get information about internals. The main difference between this and `trace`, I'd say, is that with `trace` you'd need to navigate to the function containing the `trace` to find any use out of it, while `debug` can be useful at a glance.
  - An example of `debug` in action is for the special rules. This statement contains a short `"Rules: {rules:?}"`. The intro bit indicates where the debugging line is coming from (necessary since if `rules` was `None` then the output would just be `Debug: None` which is more confusing than if it wasn't there), then the `rules` will print out all the information for the stage's special rules. I personally use this all the time, as pretty much every update adds a new Colosseum stage and I want to figure out if this is using rules that I already know or if it's something completely new, but unless you were writing code you probably don't need that much information.
  - Another example is printing out all the cat's information in `cat_info`. This is very nice because it indicates how the rest of the info was calculated, plus it shows more information than the actual output including things that are quite easy to miss.
- `info`: use this to display general information to users. A good example of this is when skipping Ms. Sign in `battlegrounds` or skipping unlinked stages in `encounters`: this happens all the time and in most cases the user can just ignore what it's saying, but for transparency it's good to know that it's removing information from the final output.
- `warn`: use this to display general information that is important and shouldn't be ignored.
  - For example, when getting `encounters`, it is possible that the extra stages heading might appear for whatever reason. This is definitely something that needs to be fixed (usually by updating `ContinueStages.csv`), but the existence of this heading isn't enough to ruin the rest of the output (the user can quite easily put the extra stage in the correct place and then their output will be correct). However, it shouldn't be ignored.
  - Another case is where something is not implemented, or is experimental and may have weird results. For example, as of time of writing, this is used for Mighty Carrowsell's LD/Omni (since it has both abilities but right now the code will only say Carrowsell has LD), or for encounters&mdash;which is advertised as being able to work for multiple enemies but right now only works for the first one that has been inputted.
  - A final case is where the output might be confusing without the warning and `info` and `error` are not applicable. For example, if a gauntlet finds that all the stages are different and therefore there is no point in using tabbers, then it will short-circuit and the tabber will be empty (because it would be useless). In this case, the rest of the output is basically useless (and thus `info` is not harsh enough), but an `error` would be too harsh, so `warn` tells the user why that happened with just the right harshness.
- `error`: not actually used because you can just crash the program. Would maybe be useful if you're doing some multi-threaded thing and one thread panics but you need to keep on going.
